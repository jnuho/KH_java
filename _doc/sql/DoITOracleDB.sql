--오라클 데이터베이스 접속 및 SCOTT계정 설정
--WIN+R CMD
--'sqlplus system/1'
--'sqlplus sys/1'
ALTER USER SCOTT IDENTIFIED BY tiger
ACCOUNT UNLOCK;

CONN scott/tiger;

EXIT

--'sqlplus scott/tiger'

DESC EMP;
DESC DEPT;
DESC SALGRADE;

--ALL / DISTINCT
SELECT ALL JOB, DEPTNO FROM EMP;

SELECT DISTINCT JOB, DEPTNO FROM EMP;

SELECT ENAME,
         SAL,
         SAL * 12 + COMM     AS ANNSAL,
         COMM
    FROM EMP
ORDER BY ANNSAL;

--ASC / DESC
SELECT * FROM EMP
ORDER BY DEPTNO ASC, SAL DESC;
  
SELECT *
  FROM EMP
 WHERE DEPTNO = 30 AND JOB = 'SALESMAN';
 
SELECT * FROM EMP
WHERE DEPTNO=20 OR JOB ='SALESMAN';
 
SELECT * 
 FROM EMP
WHERE SAL * 12 = 36000;
 
SELECT * 
 FROM EMP
 WHERE SAL >= 2500 AND JOB = 'ANALYST';
 
SELECT * FROM EMP 
  WHERE ENAME >= 'F' ORDER BY ENAME;
 
SELECT * FROM EMP
  WHERE ENAME <= 'FORZ' ORDER BY ENAME;
 
SELECT * FROM EMP
 WHERE SAL != 3000; 
/** SAL != 3000;
    SAL <> 3000;
    SAL ^= 3000;
    NOT SAL = 3000;
*/

SELECT * FROM EMP
 WHERE JOB = 'MANAGER' OR JOB = 'SALESMAN' OR JOB = 'CLERK';
 
SELECT * FROM EMP
 WHERE JOB IN ('MANAGER', 'SALESMAN', 'CLERK');
 
SELECT * FROM EMP 
WHERE JOB != 'MANAGER'
  AND JOB <> 'SALESMAN'
  AND JOB ^= 'CLERK';
 
SELECT * FROM EMP
 WHERE JOB NOT IN ('MANAGER', 'SALESMAN', 'CLERK');
 
SELECT * FROM EMP
 WHERE SAL BETWEEN 2000 AND 3000;
 
SELECT * FROM EMP
 WHERE SAL NOT BETWEEN 2000 AND 3000;
 
/*WILDCARD '%' '-' */
SELECT * FROM EMP
 WHERE ENAME LIKE 'S%';

 /* L이 두번쨰문자인 사원이름*/
SELECT * FROM EMP
 WHERE ENAME LIKE '_L%';
 
SELECT * FROM EMP
 WHERE ENAME LIKE '%AM%';
 /* WHERE ENAME NOT LIKE '%AM%' */
 
 /* 와일드 카드 문자가 데이터 일부인경우
 USE ESCAPE \ TO FIND LITERAL STRINGS WITH % AND -
 SELECT * FROM SOME_TABLE
 WHERE SOME_COLUMN LIKE 'A\_A%' ESCAPE '\'; 
 */
 
SELECT * FROM EMP
 WHERE COMM = NULL; /* CANNOT COMPARE NULL VALUE! */
 
SELECT * FROM EMP
 WHERE COMM IS NULL; /*OK*/
 
SELECT * FROM EMP
WHERE MGR IS NOT NULL;

/*
NULL + 100 = NULL
NULL > 100 = NULL
INFINITY + 100 = INFINITY
? > 100 = ?

TRUE AND NULL = NULL
FALSE AND NULL = FALSE
NULL AND NULL = NULL

TRUE OR NULL = TRUE
FALSE OR NULL = NULL
NULL OR NULL = NULL
*/

SELECT * FROM EMP
WHERE SAL > NULL
    AND COMM IS NULL;
    
SELECT * FROM EMP
WHERE SAL > NULL
    OR COMM IS NULL;


/* UNION
   INTERSECT
   MINUS
*/
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
    WHERE DEPTNO=10
UNION
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
    WHERE DEPTNO=20;

/* ERROR
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
    WHERE DEPTNO=10
UNION
SELECT EMPNO, ENAME, SAL
    FROM EMP
    WHERE DEPTNO=20;
*/

--ERROR
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
    WHERE DEPTNO=10
UNION
SELECT EMPNO, SAL, ENAME, DEPTNO
    FROM EMP
    WHERE DEPTNO=20;

--OK BECAUSE OF DATA TYPE MATCH, BUT HARD TO READ THE DATA
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
    WHERE DEPTNO=10
UNION
SELECT SAL, JOB, DEPTNO, SAL
    FROM EMP
    WHERE DEPTNO=20;

/* UNION ALL (중복포함 출력)*/
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
    WHERE DEPTNO=10
UNION
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
    WHERE DEPTNO=10;

SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
    WHERE DEPTNO=10
UNION ALL
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
    WHERE DEPTNO=10;

/* MINUS */
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
MINUS
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
    WHERE DEPTNO =10;

/* INTERSECT */
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
INTERSECT
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
    WHERE DEPTNO=10;


/* 연산자 우선순위
=====높음====
* /
+ -
= != ^= <> > >= < <=
IS (NOT) NULL, (NOT) LIKE, (NOT) IN
BETWEEN A AND B
NOT
AND
OR
=====낮음=====
*/

--CH5 PRACTICE
SELECT * FROM EMP
WHERE ENAME LIKE '%S';

SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
 FROM EMP
WHERE DEPTNO =30
AND JOB= 'SALESMAN';

SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO IN (20, 30)
AND SAL > 2000;

SELECT *
FROM EMP
WHERE SAL < 2000 OR SAL > 3000;

SELECT ENAME, EMPNO, SAL, DEPTNO
    FROM EMP
WHERE ENAME LIKE '%E%'
    AND DEPTNO =30
    AND SAL NOT BETWEEN 1000 AND 2000;

SELECT * FROM EMP
WHERE COMM IS NULL
AND MGR IS NOT NULL
AND JOB IN ('MANAGER', 'CLERK')
AND ENAME NOT LIKE '_L%';


--CHAPTER 6
SELECT ENAME, UPPER(ENAME), LOWER(ENAME), INITCAP(ENAME)
FROM EMP;

--EMPLOYEE NAMED 'SCOTT'
SELECT * FROM EMP
WHERE UPPER(ENAME) = UPPER('SCOTT');

--EMPLOYEE NAME THAT INCLUDES 'SCOTT'
SELECT * FROM EMP
WHERE UPPER(ENAME) LIKE UPPER('%SCOTT%');

SELECT ENAME, LENGTH(ENAME) FROM EMP
WHERE LENGTH(ENAME) >= 5;

--DUAL IS A DUMMY TABLE OF 'SYS' USER
SELECT LENGTH('한글'), LENGTHB('한글')
FROM DUAL;

--SUBSTR(문자열, 시작위치, 길이)
SELECT JOB, SUBSTR(JOB, 1,2), SUBSTR(JOB, 3,2), SUBSTR(JOB, 5)
FROM EMP;

SELECT ENAME, SUBSTR(ENAME, 3) FROM EMP;

SELECT JOB,
    SUBSTR(JOB, -LENGTH(JOB)),
    SUBSTR(JOB, -LENGTH(JOB), 2),
    SUBSTR(JOB, -3)
FROM EMP;

--INSTR(문자열, 찾는문자,시작위치, 몇번째)
--문자열 데이터안에서 특정 문자위치 찾는 INSTR 함수
SELECT INSTR('HELLO, ORACLE!', 'L') AS INSTR_1, --1ST 'L'
    INSTR('HELLO, ORACLE!', 'L', 5) AS INSTR_2, --5TH 'L'
    INSTR('HELLO, ORACLE!', 'L', 2, 2) AS INSTR_3  --2ND 'L' FOR INDEX >= 2
FROM DUAL;

SELECT * FROM EMP WHERE INSTR(ENAME, 'S') > 0; --INSTR() RETURNS 0 IF NOT FOUND

SELECT * FROM EMP WHERE ENAME LIKE '%S%';

--REPLACE
SELECT '010-1234-5678' AS REPLACE_BEFORE,
    REPLACE('010-1234-5678', '-', ' ') AS REPLACE_1,
    REPLACE('010-1234-5678', '-') AS REPLACE_2
FROM DUAL;

--LPAD / RPAD
SELECT 'ORACLE',
    LPAD('ORACLE', 10, '#') AS LPAD_1,
    RPAD('ORACLE', 10, '*') AS RPAD_1,
    LPAD('ORACLE', 10) AS LPAD_2,
    RPAD('ORACLE', 10) AS RPAD_2
FROM DUAL;

SELECT RPAD('97125-', 14, '*') AS RPAD_JMNO,
    RPAD('010-1234-', 13, '*') AS RPAD_PHONE
FROM DUAL;

--CONCAT
SELECT CONCAT(EMPNO, ENAME),
    CONCAT(EMPNO, CONCAT(' : ', ENAME))
FROM EMP
WHERE ENAME = 'SCOTT';

-- ||
SELECT EMPNO || ENAME,
    EMPNO || ' : ' || ENAME
FROM EMP;

--TRIM 삭제할 문자 없을때 공백 삭제
SELECT
    '[' || TRIM(' _ _ORACLE_ _ ') || ']' AS TRIM, -- '_ _ORACLE_ _'
    '[' || TRIM(LEADING FROM ' _ _ORACLE_ _ ') || ']' AS TRIM_LEADING, -- '_ _ORACLE_ _ '
    '[' || TRIM(TRAILING FROM ' _ _ORACLE_ _ ') || ']' AS TRIM_TRAILING, -- ' _ _ORACLE_ _'
    '[' || TRIM(BOTH FROM ' _ _ORACLE_ _ ') || ']' AS TRIM_BOTH -- '_ _ORACLE_ _'
FROM DUAL;

--TRIM 삭제할 문자 있을때
SELECT
    '[' || TRIM('_' FROM '_ _ORACLE_ _') || ']' AS TRIM, --[ _ORACLE_ ]
    '[' || TRIM(LEADING '_' FROM '_ _ORACLE_ _') || ']' AS TRIM_LEADING, -- ' _ORACLE_ _'
    '[' || TRIM(TRAILING '_' FROM '_ _ORACLE_ _') || ']' AS TRIM_TRAILING, -- '_ _ORACLE_ '
    '[' || TRIM(BOTH '_' FROM '_ _ORACLE_ _') || ']' AS TRIM_BOTH -- ' _ORACLE_ '
FROM DUAL;

--LTRIM RTRIM은 TRIM과 다르게 여러 문자 지정가능
SELECT
    '[' || TRIM('_' FROM ' _ORACLE_ ') || ']' AS TRIM, --[ _ORACLE_ ]
    '[' || LTRIM(' _ORACLE_ ') || ']' AS LTRIM, --[_ORACLE_ ]
    '[' || LTRIM('<_ORACLE_>', '_<') || ']' AS LTIM_2, --[ORACLE_>]
    '[' || LTRIM('<_<_ORACLE_>', '_<') || ']' AS LTIM_3, --[ORACLE_>]
    '[' || LTRIM('<_O<_RACLE_>', '_<') || ']' AS LTIM_4, --[O<_RACLE_>]
    '[' || RTRIM(' _ORACLE_ ') || ']' AS RTRIM, --[ _ORACLE_]
    '[' || RTRIM('<_ORACLE_>', '>_') || ']' AS RTRIM_2 --[<_ORACLE]
FROM DUAL;

--ROUND
SELECT ROUND(1234.5678) AS ROUND,
    ROUND(1234.5678, 0) AS ROUND_0,
    ROUND(1234.5678, 1) AS ROUND_1,
    ROUND(1234.5678, 2) AS ROUND_2,
    ROUND(1234.5678, -1) AS ROUND_MINUS1,
    ROUND(1234.5678, -2) AS ROUND_MINUS2
FROM DUAL;

--TRUNC
SELECT TRUNC(1234.5678) AS ROUND,
    TRUNC(1234.5678, 0) AS TRUNC_0,
    TRUNC(1234.5678, 1) AS TRUNC_1,
    TRUNC(1234.5678, 2) AS TRUNC_2,
    TRUNC(1234.5678, -1) AS TRUNC_MINUS1,
    TRUNC(1234.5678, -2) AS TRUNC_MINUS2
FROM DUAL;

--CEIL / FLOOR
SELECT CEIL(3.14),
       FLOOR(3.14),
       CEIL(-3.14),
       FLOOR(-3.14)
FROM DUAL;

--MOD
SELECT MOD(15, 6),
       MOD(10, 2),
       MOD(11, 2)
FROM DUAL;


--DATE
SELECT SYSDATE AS NOW,
    SYSDATE -1 AS YESTERDAY,
    SYSDATE +1 AS TOMORROW
FROM DUAL;

SELECT SYSDATE, ADD_MONTHS(SYSDATE,3)
FROM DUAL;

SELECT EMPNO, 
       ENAME,
       HIREDATE, 
       ADD_MONTHS(HIREDATE, 120) AS WORK10YEAR
FROM EMP;

SELECT EMPNO, 
       ENAME,
       HIREDATE,
       SYSDATE
FROM EMP
WHERE ADD_MONTHS(HIREDATE, 384) > SYSDATE;

SELECT EMPNO, ENAME, HIREDATE, SYSDATE,
    MONTHS_BETWEEN(HIREDATE, SYSDATE) AS MONTH1,
    MONTHS_BETWEEN(SYSDATE, HIREDATE) AS MONTH2,
    TRUNC(MONTHS_BETWEEN(SYSDATE, HIREDATE)) AS MONTH3
FROM EMP;

SELECT SYSDATE,
    NEXT_DAY(SYSDATE, '월요일'),
    LAST_DAY(SYSDATE)
FROM DUAL;

--날짜의 반올림,버림을 하는 ROUND, TRUNC 함수
-- ROUND(숫자필수, 반올림위치)
-- TRUNC(숫자필수, 버림위치)
-- ROUND(날짜필수, 반올림기준포맷)
-- TRUNC(날짜필수, 버림기준포맷)

--포맷모델
-- CC SCC                           연도끝 두자리 2050기준
-- SYYYY YYYY YEAR SYEAR YYY YY Y   7.1일 기준 (16.7.1은 17년 처리)
-- IYYY IYY IY I                    ISO8601에서 제정한 날짜 기준년도 포맷기준
-- Q                                각분기 두번째달 16일 기준
-- MONTH MON MM RM                  각달 16일 기준
-- WW                               해당연도 1~53번째 주 기준
-- IW                               ISO8601 제정 날짜 기준 해당연도의 주를 기준
-- W                                해당 월의 주(1~5번째) 기준
-- DDD DD J                         해당 일의 정오 기준
-- DAY DY D                         한주가 시작되는 날짜 기준
-- HH HH12 HH24                     해당 일의 시간을 기준
-- MI                               해당 시간의 분을 기준
SELECT SYSDATE,
    ROUND(SYSDATE, 'CC') AS FORMAT_CC,
    ROUND(SYSDATE, 'YYYY') AS FORMAT_YYYY,
    ROUND(SYSDATE, 'Q') AS FORMAT_Q,
    ROUND(SYSDATE, 'DDD') AS FORMAT_DDD,
    ROUND(SYSDATE, 'HH') AS FORMAT_HH
FROM DUAL;

SELECT SYSDATE,
    TRUNC(SYSDATE, 'CC') AS FORMAT_CC,
    TRUNC(SYSDATE, 'YYYY') AS FORMAT_YYYY,
    TRUNC(SYSDATE, 'Q') AS FORMAT_Q,
    TRUNC(SYSDATE, 'DDD') AS FORMAT_DDD,
    TRUNC(SYSDATE, 'HH') AS FORMAT_HH
FROM DUAL;

--자료형 변환 형변환 함수
SELECT EMPNO, ENAME, EMPNO + '500'
    FROM EMP
WHERE ENAME= 'SCOTT';

--ERROR
SELECT 'ABCD' + EMPNO, EMPNO
FROM EMP
WHERE ENAME='SCOTT';

SELECT
    TO_CHAR(SYSDATE, 'YYYY/MM/DD HH24:MI:SS') AS 현재날짜시간
FROM DUAL;

--FORMAT
-- CC           세기
-- YYYY RRRR    연
-- YY RR        연
-- MM           월(2자리 숫자)
-- MON          월(이름약자)
-- MONTH        월(이름전체)
-- DD           일
-- DDD          일(1년중 며칠 1~366)
-- DY           요일(요일이름 약자)
-- DAY          요일(요일이름 전체)
-- W            주(몇번째 주 1~53)

SELECT SYSDATE,
    TO_CHAR(SYSDATE, 'MM') AS MM,
    TO_CHAR(SYSDATE, 'MON', 'NLS_DATE_LANGUAGE=KOREAN') AS MON_KOR,
    TO_CHAR(SYSDATE, 'MON', 'NLS_DATE_LANGUAGE=JAPANESE') AS MON_JPN,
    TO_CHAR(SYSDATE, 'MON', 'NLS_DATE_LANGUAGE=ENGLISH') AS MON_ENG,
    TO_CHAR(SYSDATE, 'MONTH', 'NLS_DATE_LANGUAGE=KOREAN') AS MONTH_KOR,
    TO_CHAR(SYSDATE, 'MONTH', 'NLS_DATE_LANGUAGE=JAPANESE') AS MONTH_JPN,
    TO_CHAR(SYSDATE, 'MONTH', 'NLS_DATE_LANGUAGE=ENGLISH') AS MONTH_ENG
FROM DUAL;

SELECT SYSDATE,
    TO_CHAR(SYSDATE, 'MM') AS MM,
    TO_CHAR(SYSDATE, 'DD') AS DD,
    TO_CHAR(SYSDATE, 'DY', 'NLS_DATE_LANGUAGE=KOREAN') AS DY_KOR,
    TO_CHAR(SYSDATE, 'DY', 'NLS_DATE_LANGUAGE=JAPANESE') AS DY_JPN,
    TO_CHAR(SYSDATE, 'DY', 'NLS_DATE_LANGUAGE=ENGLISH') AS DY_ENG,
    TO_CHAR(SYSDATE, 'DAY', 'NLS_DATE_LANGUAGE=KOREAN') AS DAY_KOR,
    TO_CHAR(SYSDATE, 'DAY', 'NLS_DATE_LANGUAGE=JAPANESE') AS DAY_JPN,
    TO_CHAR(SYSDATE, 'DAY', 'NLS_DATE_LANGUAGE=ENGLISH') AS DAY_ENG
FROM DUAL;

-- FORMAT
-- HH24             24시간으로 표현           
-- HH HH12          12시간으로 표현
-- MI               분
-- SS               초
-- AM PM A.M. P.M.    오전, 오후 표시

SELECT SYSDATE,
    TO_CHAR(SYSDATE, 'HH24:MI:SS') AS HH24MISS,
    TO_CHAR(SYSDATE, 'HH12:MI:SS AM') AS HHMISS_AM,
    TO_CHAR(SYSDATE, 'HH12:MI:SS P.M.') AS HHMISS_PM
FROM DUAL;

--9 숫자한자리
--0 빈자리 채움
--$ 달러표시
--L 지역화폐단위 기호
--. 소수점표시
--, 천 단위 구분기호 표시
SELECT SAL,
    TO_CHAR(SAL, '$999,999') AS SAL_$,
    TO_CHAR(SAL, 'L999,999') AS SAL_L,
    TO_CHAR(SAL, '999,999.00') AS SAL_1,
    TO_CHAR(SAL, '000,999,999.00') AS SAL_2,
    TO_CHAR(SAL, '000999999.99') AS SAL_3,
    TO_CHAR(SAL, '999,999,00') AS SAL_4
FROM EMP;

SELECT 1300-'1500',
    '1300' + 1500
FROM DUAL;

--ERROR!
SELECT '1,300'-'1,500'
FROM DUAL;

SELECT TO_NUMBER('1,300', '999,999') - TO_NUMBER('1,500', '999,999')
FROM DUAL;

SELECT TO_DATE('2018-07-14', 'YYYY-MM-DD') AS TODATE1,
    TO_DATE('20180714', 'YYYY-MM-DD') AS TODATE2
FROM DUAL;

SELECT *
    FROM EMP
WHERE HIREDATE > TO_DATE('1981/06/01', 'YYYY/MM/DD');

SELECT TO_DATE('49/12/10', 'YY/MM/DD') AS YY_YEAR_49,
    TO_DATE('49/12/10', 'RR/MM/DD') AS RR_YEAR_49,
    TO_DATE('50/12/10', 'YY/MM/DD') AS YY_YEAR_50,
    TO_DATE('50/12/10', 'RR/MM/DD') AS RR_YEAR_50,
    TO_DATE('51/12/10', 'YY/MM/DD') AS YY_YEAR_51,
    TO_DATE('51/12/10', 'RR/MM/DD') AS RR_YEAR_51
FROM DUAL;


-- NULL 처리 함수
--NVL(데이터, IF NULL 데이터)
--NVL2(데이터, IF NOT NULL 데이터, IF NULL 데이터)
SELECT EMPNO, ENAME, SAL, COMM, SAL+COMM,
    NVL(COMM, 0),
    SAL+NVL(COMM, 0)
FROM EMP;

SELECT EMPNO, ENAME, COMM,
    NVL2(COMM, 'O', 'X'),
    NVL2(COMM, SAL*12 + COMM, SAL*12) AS ANNSAL
FROM EMP;

--상황에 따라 다른 데이터를 반환하는 DECODE 함수와 CASE 문

--DECODE (열/데이터/연산/함수결과,
--        조건1, 일치시 반환할 결과,
--        조건2, 일치시 반환할 결과,
--        ...
--        조건N, 일치시 반환할 결과,
--        조건1~N과 불일치시 반환할 결과)
--IF DEFAULT IS OMITTED AND NO MATCHES ARE FOUND, THEN NULL IS RETURNED.
SELECT EMPNO, ENAME, JOB, SAL,
    DECODE(JOB,
            'MANAGER', SAL*1.1,
            'SALESMAN', SAL*1.05,
            'ANALYST', SAL,
            SAL*1.03) AS UPSAL
FROM EMP;

--CASE 문
--각조건에 사용하는 데이터가 서로 상관없어도 됨. (=) 외에 다양한 조건 사용가능.
--기준 데이터 없어도, 각조건식의 TRUE/FALSE여부만 검사.
SELECT EMPNO, ENAME, JOB, SAL,
    CASE JOB
         WHEN 'MANAGER' THEN SAL*1.1
         WHEN 'SALESMAN' THEN SAL*1.05
         WHEN 'ANALYST' THEN SAL
         ELSE SAL*1.03
    END AS UPSAL
FROM EMP;

SELECT EMPNO, ENAME, COMM,
    CASE
        WHEN COMM IS NULL THEN '해당사항 없음'
        WHEN COMM = 0 THEN '수당없음'
        WHEN COMM > 0 THEN '수당: ' || COMM
    END AS COMM_TEXT
FROM EMP;

--PRACTICE 6-1
SELECT EMPNO, 
    RPAD(SUBSTR(EMPNO, 1,2), LENGTH(EMPNO), '*') AS MASKING_EMPNO,
    ENAME,
    RPAD(SUBSTR(ENAME, 1,1), LENGTH(ENAME), '*') AS MASKING_ENAME
FROM EMP
WHERE LENGTH(ENAME) = 5;

--PRACTICE 6-2
SELECT EMPNO, 
    ENAME,
    SAL,
    TRUNC(SAL/21.5, 2) AS DAY_PAY,
    ROUND(SAL/(21.5*8), 1) AS TIME_PAY
FROM EMP;

--PRACTICE 6-3
SELECT EMPNO,
    ENAME,
    HIREDATE,
    NEXT_DAY(ADD_MONTHS(HIREDATE, 3), '월요일') AS R_JOB,
    NVL(TO_CHAR(COMM), 'N/A') AS COMM
FROM EMP;

--PRACTICE 6-4
SELECT EMPNO,
    ENAME,
    MGR,
    CASE
        WHEN MGR IS NULL THEN '0000'
        WHEN SUBSTR(MGR,1,2) = '75' THEN '5555'
        WHEN SUBSTR(MGR,1,2) = '76' THEN '6666'
        WHEN SUBSTR(MGR,1,2) = '77' THEN '7777'
        WHEN SUBSTR(MGR,1,2) = '78' THEN '8888'
        ELSE TO_CHAR(MGR)
    END AS CHG_MGR
FROM EMP;


--CHAPTER 7 다중행함수와 데이터그룹화
SELECT SUM(SAL) FROM EMP;

--ERROR 단일 그룹의 함수가 아닙니다
SELECT ENAME, SUM(SAL) FROM EMP;

--SUM
--COUNT
--MAX
--MIN
--AVG

SELECT SUM(COMM) FROM EMP;

SELECT SUM(DISTINCT SAL),
    SUM(ALL SAL),
    SUM(SAL)
FROM EMP;

--행 수
SELECT COUNT(*) FROM EMP WHERE DEPTNO = 30;

SELECT COUNT(DISTINCT SAL),
    COUNT(ALL SAL),
    COUNT(SAL)
FROM EMP;

--NULL은 개수에서 제외
SELECT COUNT(COMM) FROM EMP;

SELECT COUNT(COMM) FROM EMP WHERE COMM IS NOT NULL;

SELECT MAX(SAL), MIN(SAL)
FROM EMP
WHERE DEPTNO = 10;

SELECT MAX(HIREDATE), MIN(HIREDATE)
FROM EMP
WHERE DEPTNO = 20;

SELECT AVG(SAL), AVG(DISTINCT SAL) FROM EMP WHERE DEPTNO = 30;


--GROUP BY 결과 값을 원하는 열로 묶어 출력
SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 10;

SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 20;

SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 30;

--UNION ALL
SELECT AVG(SAL), '10' AS DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT AVG(SAL), '20' AS DEPTNO FROM EMP WHERE DEPTNO = 20
UNION ALL
SELECT AVG(SAL), '30' AS DEPTNO FROM EMP WHERE DEPTNO = 30;

--GROUP BY
--SELECT [] FROM [] WHERE [] GROUP BY [그룹화할 열지정] ORDER BY []
--다중행 함수 사용하지 않은 일반열은 GROUP BY절에 명시하지 않으면 오류.
SELECT AVG(SAL), DEPTNO
    FROM EMP
GROUP BY DEPTNO;

SELECT DEPTNO, JOB, AVG(SAL)
    FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

SELECT DEPTNO, AVG(COMM)
    FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

--GROUP BY절에 조건을 줄때 사용하는 HAVING절
--HAVING [그룹화된 결과 중, 출력 그룹을 제한하는 조건식]
SELECT DEPTNO, JOB, AVG(SAL)
    FROM EMP
GROUP BY DEPTNO, JOB
    HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;

/* WITHOUT USING 'HAVING AVG(SAL) >= 2000'
10	MANAGER	    2450
10	PRESIDENT	5000
...
30	MANAGER	    2850
*/
--HAVING대신 WHERE 사용시 ERROR!
--GROUP BY 전 WHERE SAL>=2000 가능

--ROLLUP, CUBE 그룹화 데이터의 합계를 함께 출력 시
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
    FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
    FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB);

SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
    FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--N COLUMNS
--ROLLUP N+1, CUBE 2^N

--PARTIAL ROLLUP/CUBE
SELECT DEPTNO, JOB, COUNT(*)
    FROM EMP
GROUP BY DEPTNO, ROLLUP(JOB);

SELECT DEPTNO, JOB, COUNT(*)
    FROM EMP
GROUP BY JOB, ROLLUP(DEPTNO);

--GROUPING SETS 지정한 모든열을 각각 대그룹으로 처리하여 출력
--그룹화를 위해 지정한 열이 계층적으로 분류되지 않고 각각 따로 그룹화한 후 연산수행.
SELECT DEPTNO, JOB, COUNT(*)
    FROM EMP
GROUP BY GROUPING SETS(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--그룹화 함수 GROUPING, GROUPING_ID
--그룹화 데이터 식별, 가독성 높이기 위함
--GROUPING 그룹화 대상열이 그룹화된 상태로 결과 집계되었는지 확인하기 위함.
--그룹화된 상태 0, 그룹화 되지 않은 상태 1 반환
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL),
        GROUPING(DEPTNO),
        GROUPING(JOB)
    FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

SELECT DECODE(GROUPING(DEPTNO), 1, 'ALL_DEPT', DEPTNO) AS DEPTNO,
       DECODE(GROUPING(JOB), 1, 'ALL_JOB', JOB) AS JOB,
       COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
    FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--GROUPING_ID
--그룹화 여부 검사할 열을 하나씩 지정하는 GROUPING함수와 달리 한번에 여러 열 지정 가능
SELECT DEPTNO, JOB, COUNT(*), SUM(SAL),
       GROUPING(DEPTNO),
       GROUPING(JOB),
       GROUPING_ID(DEPTNO, JOB)
    FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--그룹화된 열 | 그룹화 BIT | 최종결과(10진수)
--A B       |  0 0      |    0
--A         |  0 1      |    1
--  B       |  1 0      |    2
--          |  1 1      |    3


--LISTAGG
--SELECT [] LISTAGG(열이름, 구분자(선택)) WITHIN GROUP(ORDER BY 나열 열 정렬기준)
--FROM [] WHERE [];
SELECT ENAME FROM EMP WHERE DEPTNO = 10;

SELECT DEPTNO, ENAME
    FROM EMP
GROUP BY DEPTNO, ENAME
ORDER BY DEPTNO, ENAME;

--LISTAGG
SELECT DEPTNO,
       LISTAGG(ENAME, ', ')
       WITHIN GROUP(ORDER BY SAL DESC) AS ENAMES
    FROM EMP
GROUP BY DEPTNO;

SELECT E1.MGR, E2.ENAME,
       LISTAGG(E1.ENAME, ', ')
       WITHIN GROUP (ORDER BY E1.EMPNO DESC) AS ENAMES
    FROM EMP E1, EMP E2
    WHERE E1.MGR = E2.EMPNO
GROUP BY E1.MGR, E2.ENAME
ORDER BY E1.MGR;

--PIVOT(행->열), UNPIVOT(열->행)
SELECT DEPTNO, JOB, MAX(SAL)
    FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

SELECT *
    FROM(SELECT DEPTNO, JOB, SAL
            FROM EMP)
  PIVOT(MAX(SAL)
        FOR DEPTNO IN (10, 20, 30)
       )
ORDER BY JOB;

SELECT *
    FROM(SELECT JOB, DEPTNO, SAL
            FROM EMP)
  PIVOT(MAX(SAL)
        FOR JOB IN ('CLERK' AS CLERK,
                    'SALESMAN' AS SALESMAN,
                    'PRESIDENT' AS PRESIDENT,
                    'MANAGER' AS MANAGER,
                    'ANALYST' AS ANALYST)
        )
ORDER BY DEPTNO;

--WITHOUT PIVOT IN PRE-'ORACLE 11G' VERSIONS
SELECT DEPTNO,
    MAX(DECODE(JOB, 'CLERK', SAL)) AS "CLERK",
    MAX(DECODE(JOB, 'SALESMAN', SAL)) AS "SALESMAN",
    MAX(DECODE(JOB, 'PRESIDENT', SAL)) AS "PRESIDENT",
    MAX(DECODE(JOB, 'MANAGER', SAL)) AS "MANAGER",
    MAX(DECODE(JOB, 'ANALYST', SAL)) AS "ANALYST"
  FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

--UNPIVOT
--세로로 늘어뜨릴 가로열을 FOR에 명시
SELECT *
    FROM(SELECT DEPTNO,
                MAX(DECODE(JOB, 'CLERK', SAL)) AS "CLERK",
                MAX(DECODE(JOB, 'SALESMAN', SAL)) AS "SALESMAN",
                MAX(DECODE(JOB, 'PRESIDENT', SAL)) AS "PRESIDENT",
                MAX(DECODE(JOB, 'MANAGER', SAL)) AS "MANAGER",
                MAX(DECODE(JOB, 'ANALYST', SAL)) AS "ANALYST"
            FROM EMP
        GROUP BY DEPTNO
        ORDER BY DEPTNO)
  UNPIVOT(
    SAL FOR JOB IN (CLERK, SALESMAN, PRESIDENT, MANAGER, ANALYST))
ORDER BY DEPTNO, JOB;


--PRACTICE 8-1
SELECT DEPTNO, 
       TRUNC(AVG(SAL)) AS AVG_SAL,
       MAX(SAL) AS MAX_SAL,
       MIN(SAL) AS MIN_SAL,
       COUNT(*) AS CNT
    FROM EMP
GROUP BY DEPTNO;

--PRACTICE 8-2
SELECT JOB, COUNT(*)
    FROM EMP
GROUP BY JOB
    HAVING COUNT(*) >= 3;

--PRACTICE 8-3
SELECT TO_CHAR(HIREDATE, 'YYYY') AS HIRE_YEAR,
       DEPTNO,
       COUNT(*) AS CNT
    FROM EMP
GROUP BY TO_CHAR(HIREDATE, 'YYYY'), DEPTNO;

--PRACTICE 8-4
SELECT NVL2(COMM, 'O', 'X') AS EXIST_COMM,
       COUNT(*) AS CNT
    FROM EMP
GROUP BY NVL2(COMM, 'O', 'X');

--PRACTICE 8-5
SELECT DEPTNO,
       TO_CHAR(HIREDATE, 'YYYY') AS HIRE_YEAR,
       COUNT(*) AS CNT,
       MAX(SAL) AS MAX_SAL,
       SUM(SAL) AS SUM_SAL,
       AVG(SAL) AS AVG_SAL
    FROM EMP
GROUP BY ROLLUP(DEPTNO, TO_CHAR(HIREDATE, 'YYYY'));


--CHAPTER 8 JOIN
SELECT *
    FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
ORDER BY EMPNO;

SELECT E.EMPNO, E.ENAME, E.JOB, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO,
       D.DNAME, D.LOC
    FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY EMPNO;

--INNER(SIMPLE, 등가 EQUI) JOIN
SELECT EMPNO, ENAME, D.DEPTNO, DNAME, LOC
    FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
      AND SAL >= 3000
ORDER BY D.DEPTNO, E.EMPNO;

--N개 테이블 조인시, 데카르트 곱 현상 피하기 위한 조건식 최소 N-1개 이상 필요


--비등가(NON-EQUI) JOIN
SELECT *
    FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

--자체조인
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
    FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;

--OUTER 외부 JOIN
--JOIN 기준열의 어느 한쪽이 NULL임에도 결과에 강제로 포함시켜야 할때 필요.
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
    FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+)
ORDER BY E1.EMPNO;

SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
    FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO
ORDER BY E1.EMPNO;

--SQL-99 표준문법으로 배우는 조인
--NATUAL JOIN 자동으로 조인 기준열이 지정됨
--기준열을 SELECT 절에 명시할때 테이블이름 생략.
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM,
       DEPTNO, D.DNAME, D.LOC
    FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, E.EMPNO;

--JOIN ~ USING
--기준열을 SELECT 절에 명시할때 테이블이름 생략.
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM,
       DEPTNO, D.DNAME, D.LOC
    FROM EMP E JOIN DEPT D USING(DEPTNO)
    WHERE SAL >= 3000
ORDER BY DEPTNO, E.EMPNO;

--JOIN ~ ON
--기준열을 SELECT 절에 명시할때 테이블이름 명시.
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM,
       E.DEPTNO, D.DNAME, D.LOC
    FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
    WHERE SAL <= 3000
ORDER BY E.DEPTNO, E.EMPNO;

--OUTER JOIN
--LEFT OUTER JOIN 기존    WHERE TABLE1.COL1 = TABLE2.COL1(+)
--                SQL-99 FROM TABLE1 LEFT OUTER JOIN TABLE2 ON (T1.COL1 = T2.COL2)

--RIGHT OUTER JOIN 기존   WHERE TABLE1.COL1(+) = TABLE2.COL1
--                SQL-99 FROM TABLE1 RIGHT OUTER JOIN TABLE2 ON (T1.COL1 = T2.COL2)

--FULL OUTER JOIN 기존    기본 문법은 없음(UNION 집합 연사자를 활용)
--                SQL-99 FROM TABLE1 FULL OUTER JOIN TABLE2 ON (T1.COL1 = T2.COL2)
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
    FROM EMP E1 LEFT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;
--WHERE E1.MGR = E2.EMPNO(+) //NON-SQL-99


SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
    FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO, MGR_EMPNO;
--WHERE E1.MGR(+) = E2.EMPNO //NON-SQL-99

SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
    FROM EMP E1 FULL OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;

--SQL-99 조인 방식에서 3개이상의 테이블을 조인할때
/*
기존 JOIN:
FROM T1, T2, T3
WHERE T1.A = T2.B
  AND T2.B = T3.C;

SQL-99 JOIN:
FROM T1, T2, T3
WHERE T1 JOIN T2 ON (조건식)
    JOIN T3 ON (조건식);
*/

--PRACTICE 8-1

--NON-'SQL-99'
SELECT E.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
    FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
  AND E.SAL > 2000
ORDER BY E.DEPTNO, E.SAL;

--SQL-99
SELECT DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
    FROM EMP E JOIN DEPT D USING(DEPTNO)
WHERE E.SAL > 2000
ORDER BY DEPTNO, E.SAL;

SELECT DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
    FROM EMP E NATURAL JOIN DEPT D
WHERE E.SAL > 2000
ORDER BY DEPTNO, E.SAL;

--PRACTICE 8-2
SELECT D.DEPTNO,
       D.DNAME,
       TRUNC(AVG(E.SAL)) AS AVG_SAL, 
       MAX(E.SAL) AS MAX_SAL,
       MIN(E.SAL) AS MIN_SAL,
       COUNT(*) AS CNT
    FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
GROUP BY D.DEPTNO, D.DNAME;

SELECT DEPTNO,
       D.DNAME,
       TRUNC(AVG(E.SAL)) AS AVG_SAL, 
       MAX(E.SAL) AS MAX_SAL,
       MIN(E.SAL) AS MIN_SAL,
       COUNT(*) AS CNT
    FROM EMP E JOIN DEPT D USING(DEPTNO)
GROUP BY DEPTNO, D.DNAME;

--PRACTICE 8-3
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
    FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO
ORDER BY D.DEPTNO, E.ENAME;

SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
    FROM EMP E RIGHT OUTER JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
ORDER BY D.DEPTNO, E.ENAME;

--PRACTICE 8-4
SELECT D.DEPTNO,
       D.DNAME,
       E.EMPNO,
       E.ENAME,
       E.MGR,
       E.SAL,
       E.DEPTNO,
       S.LOSAL,
       S.HISAL,
       S.GRADE,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
    FROM EMP E, DEPT D, SALGRADE S, EMP E2
WHERE E.DEPTNO(+) = D.DEPTNO
  AND E.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
  AND E.MGR = E2.EMPNO(+)
ORDER BY D.DEPTNO, E.EMPNO;

SELECT D.DEPTNO,
       D.DNAME,
       E.EMPNO,
       E.ENAME,
       E.MGR,
       E.SAL,
       E.DEPTNO,
       S.LOSAL,
       S.HISAL,
       S.GRADE,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
    FROM EMP E RIGHT OUTER JOIN DEPT D 
                    ON(E.DEPTNO = D.DEPTNO)
               LEFT OUTER JOIN SALGRADE S 
                    ON(E.SAL BETWEEN S.LOSAL AND S.HISAL)
               LEFT OUTER JOIN EMP E2
                    ON (E.MGR = E2.EMPNO)
ORDER BY D.DEPTNO, E.EMPNO;

--CHAPTER 9 SUBQUERY
SELECT * FROM EMP
    WHERE SAL > (SELECT SAL
                    FROM EMP 
                  WHERE ENAME = 'JONES');

--SUBQUERY
--1. USE ()
--2. NO 'ORDER BY'
--3. SUBQUERY SAME 'DATA TYPE' AND 'NUMBER OF DATA' AS MAIN QUERY SELECT CLAUSE
--4. SUBQUERY RESULT ROW NUMBER SHOULD BE COMPATIBLE TO MAIN QUERY

--단일행 서브쿼리
SELECT * FROM EMP
    WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME = 'SCOTT');

SELECT E.EMPNO, E.ENAME, E.JOB, E.SAL, D.DEPTNO, D.DNAME, D.LOC
    FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
    AND E.DEPTNO = 20
    AND E.SAL > (SELECT AVG(SAL) FROM EMP);

--다중행 서브쿼리
--다중행 연산자

--IN
SELECT * FROM EMP WHERE DEPTNO IN (20,30);

SELECT * FROM EMP
    WHERE SAL IN (SELECT MAX(SAL) 
                    FROM EMP GROUP BY DEPTNO);

--ANY, SOME
SELECT * FROM EMP
    WHERE SAL = ANY(SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

SELECT * FROM EMP
    WHERE SAL = SOME(SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

--  SAL < ANY(950, 1250,... 2850) == (SAL < 2850)
SELECT * FROM EMP 
    WHERE SAL < ANY(SELECT SAL FROM EMP WHERE DEPTNO = 30)
ORDER BY SAL, EMPNO;

SELECT * FROM EMP 
    WHERE SAL < (SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30)
ORDER BY SAL, EMPNO;

--  SAL > ANY(950, ... , 2850) == (SAL > 950)
SELECT * FROM EMP 
    WHERE SAL > ANY(SELECT SAL FROM EMP WHERE DEPTNO = 30)
ORDER BY SAL, EMPNO;

--ALL
SELECT * FROM EMP 
    WHERE SAL < ALL(SELECT SAL FROM EMP WHERE DEPTNO = 30)
ORDER BY SAL, EMPNO;

SELECT * FROM EMP 
    WHERE SAL > ALL(SELECT SAL FROM EMP WHERE DEPTNO = 30)
ORDER BY SAL, EMPNO;

SELECT * FROM EMP
    WHERE HIREDATE < ALL(SELECT HIREDATE FROM EMP WHERE DEPTNO=10);

--EXISTS
SELECT * FROM EMP
    WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO = 10);

SELECT * FROM EMP
    WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO = 50);

--다중열 서브쿼리
SELECT *
    FROM EMP
  WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) 
                                FROM EMP 
                              GROUP BY DEPTNO);

--WITH절
--  FROM절에 긴 서브쿼리 대신 가독성 높이기위해
SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
    FROM (SELECT * FROM EMP WHERE DEPTNO=10) E10,
         (SELECT * FROM DEPT) D
    WHERE E10.DEPTNO = D.DEPTNO;

--WITH
--[별칭1] AS (SELECT문 1),
--[별칭2] AS (SELECT문 2),
--...
--[별칭N] AS (SELECT문 N)
--SELECT 
--  FROM 별칭1, 별칭2, ...
WITH E10 AS (SELECT * FROM EMP WHERE DEPTNO = 10),
       D AS (SELECT * FROM DEPT)
  SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
        FROM E10, D
    WHERE E10.DEPTNO = D.DEPTNO;

--상호연관(CORRELATED) 서브쿼리 
--LOW PERFORMANCE, NOT USED OFTEN
SELECT * FROM EMP E1
    WHERE SAL > (SELECT MIN(SAL)
                    FROM EMP E2
                  WHERE E2.DEPTNO = E1.DEPTNO)
ORDER BY DEPTNO, SAL;

--SELECT절에 사용하는 서브쿼리
SELECT EMPNO, ENAME, JOB, SAL,
       (SELECT GRADE
            FROM SALGRADE
          WHERE E.SAL BETWEEN LOSAL AND HISAL) AS SALGRADE,
       DEPTNO,
       (SELECT DNAME
            FROM DEPT
          WHERE E.DEPTNO = DEPT.DEPTNO) AS DNAME
    FROM EMP E;

SELECT * FROM SALGRADE;

--PRACTICE 9-1
SELECT E.JOB, E.EMPNO, E.SAL, E.DEPTNO, D.DNAME
    FROM EMP E, DEPT D
  WHERE E.DEPTNO = D.DEPTNO
    AND E.JOB = (SELECT JOB 
                    FROM EMP 
                  WHERE ENAME='ALLEN');

--PRACTICE 9-2
SELECT E.EMPNO, 
       E.ENAME,
       D.DNAME,
       E.HIREDATE,
       D.LOC,
       E.SAL,
       S.GRADE
    FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO = D.DEPTNO
  AND E.SAL BETWEEN S.LOSAL AND S.HISAL
  AND SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY E.SAL DESC, E.EMPNO;

--PRACTICE 9-3
SELECT E.EMPNO, E.ENAME, E.JOB, E.DEPTNO, D.DNAME, D.LOC
    FROM EMP E, DEPT D
  WHERE E.DEPTNO = D.DEPTNO
    AND E.DEPTNO=10
    AND E.JOB NOT IN
        (SELECT DISTINCT JOB 
            FROM EMP
          WHERE DEPTNO=30);

--PRACTICE 9-4
SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
    FROM EMP E, SALGRADE S
  WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
    AND E.SAL > (SELECT MAX(SAL) 
                    FROM EMP 
                  WHERE JOB='SALESMAN')
ORDER BY E.EMPNO;

SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
    FROM EMP E, SALGRADE S
  WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
    AND E.SAL > ALL (SELECT DISTINCT SAL
                    FROM EMP 
                  WHERE JOB='SALESMAN')
ORDER BY E.EMPNO;


--CHAPTER10
--DML(DATA MANIPULATION LANGUAGE)
CREATE TABLE DEPT_TEMP
    AS SELECT * FROM DEPT;

DROP TABLE DEPT_TEMP;

--INSERT
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) VALUES(50, 'DATABASE', 'SEOUL');

INSERT INTO DEPT_TEMP VALUES(60, 'NETWORK', 'BUSAN');

SELECT * FROM DEPT_TEMP;

--NULL데이터 입력 - EXPLICIT
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) VALUES(70, 'WEB', NULL);

INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) VALUES(80, 'MOBILE', '');

--NULL데이터 입력 - IMPLICIT
INSERT INTO DEPT_TEMP(DEPTNO, LOC) VALUES(90, 'INCHEON');


--날짜 데이터 입력
--테이블 복사만 하고, 데이터는 넣고 싶지 않을 때
CREATE TABLE EMP_TEMP 
    AS SELECT * FROM EMP 
        WHERE 1<> 1;

SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
                VALUES(9999, '홍길동', 'PRESIDENT', NULL, '2001/01/01',
                        5000, 1000, 10);

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
                VALUES(1111, '성춘향', 'MANAGER', 9999, '2001-01-05',
                        4000, NULL, 20);

--ERROR: DATE FORMAT
INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
                VALUES(2111, '이순신', 'MANAGER', 9999, '07/01/2001',
                        4000, NULL, 20);

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
                VALUES(2111, '이순신', 'MANAGER', 9999, 
                        TO_DATE('07/01/2001', 'DD/MM/YYYY'),
                        4000, NULL, 20);

SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
                VALUES(3111, '심청이', 'MANAGER', 9999, SYSDATE,
                        4000, NULL, 30);

--서브쿼리로 한번에 여러데이터 추가하기.
--1. VALUES절 생략
--2. 서브쿼리와, 추가되는 테이블의 열개수 일치
--3. 자료형 일치
INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
                SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR,
                       E.HIREDATE, E.SAL, E.COMM, E.DEPTNO
                    FROM EMP E, SALGRADE S
                  WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
                    AND S.GRADE = 1;

SELECT * FROM EMP_TEMP;

--USE MERGE! docs.oracle.com 참고.
--같은 열구조를 가지는 여러테이블 또는 서브쿼리의 결과 데이터를 한테이블에 병합하여 추가. 


--UPDATE ~ SET 테이블 데이터 수정
CREATE TABLE DEPT_TEMP2 AS SELECT * FROM DEPT;

UPDATE DEPT_TEMP2
    SET LOC = 'SEOUL';

SELECT * FROM DEPT_TEMP2;

--ROLLBACK <-> COMMIT (TCL)
--ROLLBACK DML COMMANDS: INSERT UPDATE DELETE
ROLLBACK;

--데이터 일부 수정
UPDATE DEPT_TEMP2
    SET DNAME = 'DATABASE', LOC = 'SEOUL'
        WHERE DEPTNO=40;

SELECT * FROM DEPT_TEMP2;

--SUBQUERY TO UPDATE DATA
UPDATE DEPT_TEMP2
    SET (DNAME, LOC) = (SELECT DNAME, LOC
                            FROM DEPT
                          WHERE DEPTNO =40)
      WHERE DEPTNO = 40;

SELECT * FROM DEPT_TEMP2;

--열 하나하나 데이터 수정
UPDATE DEPT_TEMP2
    SET DNAME = (SELECT DNAME
                    FROM DEPT
                  WHERE DEPTNO = 40),
        LOC = (SELECT LOC
                    FROM DEPT
                  WHERE DEPTNO = 40)
      WHERE DEPTNO = 40;

--WHERE절에 서브쿼리로 데이터 수정
UPDATE DEPT_TEMP2
    SET LOC = 'SEOUL'
  WHERE DEPTNO = (SELECT DEPTNO
                    FROM DEPT_TEMP2
                  WHERE DNAME = 'OPERATIONS');

SELECT * FROM DEPT_TEMP2;


--DELETE 테이블 데이터 삭제
CREATE TABLE EMP_TEMP2
    AS SELECT * FROM EMP;

SELECT * FROM EMP_TEMP2;

--데이터 일부만 삭제
DELETE FROM EMP_TEMP2
    WHERE JOB = 'MANAGER';

DELETE FROM EMP_TEMP2
    WHERE EMPNO IN (SELECT E.EMPNO
                        FROM EMP_TEMP2 E, SALGRADE S
                      WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
                        AND S.GRADE = 3
                        AND DEPTNO = 30);

SELECT * FROM EMP_TEMP2;

--데이터 전체 삭제
DELETE FROM EMP_TEMP2;


--PRACTICE 10-1
CREATE TABLE CHAP10HW_EMP AS SELECT * FROM EMP;

CREATE TABLE CHAP10HW_DEPT AS SELECT * FROM DEPT;

CREATE TABLE CHAP10HW_SALGRADE AS SELECT * FROM SALGRADE;

INSERT INTO CHAP10HW_DEPT (DEPTNO, DNAME, LOC) VALUES (50, 'ORACLE', 'BUSAN');

INSERT INTO CHAP10HW_DEPT (DEPTNO, DNAME, LOC) VALUES (60, 'SQL', 'ILSAN');

INSERT INTO CHAP10HW_DEPT (DEPTNO, DNAME, LOC) VALUES (70, 'SELECT', 'INCHEON');

INSERT INTO CHAP10HW_DEPT (DEPTNO, DNAME, LOC) VALUES (80, 'DML', 'BUNDANG');

--PRACTICE 10-2
INSERT INTO CHAP10HW_EMP
VALUES(7201, 'TEST_USER1', 'MANAGER', 7788, TO_DATE('2016-01-02', 'YYYY-MM-DD'), 4500, NULL, 50);
 
INSERT INTO CHAP10HW_EMP
VALUES(7202, 'TEST_USER2', 'CLERK', 7201, TO_DATE('2016-02-21', 'YYYY-MM-DD'), 1800, NULL, 50);
 
INSERT INTO CHAP10HW_EMP
VALUES(7203, 'TEST_USER3', 'ANALYST', 7201, TO_DATE('2016-04-11', 'YYYY-MM-DD'), 3400, NULL, 60);
 
INSERT INTO CHAP10HW_EMP
VALUES(7204, 'TEST_USER4', 'SALESMAN', 7201, TO_DATE('2016-05-31', 'YYYY-MM-DD'), 2700, 300, 60);
 
INSERT INTO CHAP10HW_EMP
VALUES(7205, 'TEST_USER5', 'CLERK', 7201, TO_DATE('2016-07-20', 'YYYY-MM-DD'), 2600, NULL, 70);
 
INSERT INTO CHAP10HW_EMP
VALUES(7206, 'TEST_USER6', 'CLERK', 7201, TO_DATE('2016-09-08', 'YYYY-MM-DD'), 2600, NULL, 70);
 
INSERT INTO CHAP10HW_EMP
VALUES(7207, 'TEST_USER7', 'LECTURER', 7201, TO_DATE('2016-10-28', 'YYYY-MM-DD'), 2300, NULL, 80);
 
INSERT INTO CHAP10HW_EMP
VALUES(7208, 'TEST_USER8', 'STUDENT', 7201, TO_DATE('2018-03-09', 'YYYY-MM-DD'), 1200, NULL, 80);

--PRACTICE 10-3
UPDATE CHAP10HW_EMP
    SET DEPTNO = 70
    WHERE SAL > (SELECT AVG(SAL) 
                    FROM CHAP10HW_EMP
                  WHERE DEPTNO = 50);

--PRACTICE 10-4
UPDATE CHAP10HW_EMP
    SET SAL = SAL * 1.1,
        DEPTNO = 80
    WHERE HIREDATE > (SELECT MIN(HIREDATE)
                    FROM CHAP10HW_EMP
                  WHERE DEPTNO = 60);

--PRACTICE 10-5
DELETE FROM CHAP10HW_EMP
    WHERE EMPNO IN (SELECT E.EMPNO
                        FROM CHAP10HW_EMP E, CHAP10HW_SALGRADE S
                      WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
                            AND S.GRADE = 5);

SELECT * FROM CHAP10HW_EMP;

SELECT * FROM CHAP10HW_DEPT;

SELECT * FROM CHAP10HW_SALGRADE;


--CHAPTER11
--TCL(TRANSACTION CONTROL LANGUAGE)
--ROLLBACK; CANCEL TRANSACTIONS
--COMMIT; APPLY TRANSACTONS PERMANENTLY

--SESSIONS : READ CONSISTENCY

--LOCK
--특정 세션에서 조작중인 데이터는 TRANSACTION이 완료(COMMIT, ROLLBACK)전 까지
--다른 세션에서 조작할 수 없는 잠금상태가 됩니다.(LOCK)
--세션 A에서 UPDATE/DELETE 실행 후, COMMIT/ROLLBACK하지 않으면,
--세션 B에서 UPDATE/DELETE 할 수 없음 (HANG 현상) (SESSION LOCK)

--조작 데이터가 특정 행일 경우 (WHERE절 있을때), 해당 ROW만 (ROW LEVEL LOCK)
--WHERE절 없는 UPDATE/DELETE문으로 모든 ROW 데이터에 영향줄경우
--예를들어 UPDATE DEPT_TCL SET LOC = 'SEOUL'; DELETE FROM DEPT_TCL;
--위의 경우 테이블에 저장되있는 전체 행이 LOCK.
--전체 행이 LOCK 상태여도, INSERT문의 수행은 가능.

--하지만 변경되는 행의 수와 상관없이 DML일 경우, TABLE LEVEL LOCK.
--즉, 다른 세션에서 DDL을 통한 테이블 구조변경 불가능(LOCK)


--CHAPTER 12
--DDL(DATA DEFINITION LANGUAGE)
--데이터정의어는 사용과 동시에 COMMIT 효과; 직전에 사용한 DML도 전부 COMMIT됨.
--CREATE, ALTER, DROP

--  CREATE TABLE 소유계정.테이블이름(
--      열1이름    열1자료형,
--      열2이름    열2자료형,
--      ...
--      열N이름    열N자료형
--  );

--자료형 직접정의
CREATE TABLE EMP_DDL(
    EMPNO       NUMBER(4),
    ENAME       VARCHAR2(10),
    JOB         VARCHAR2(9),
    MGR         NUMBER(4),
    HIREDATE    DATE,
    SAL         NUMBER(7, 2), -- (EX) 12345.67
    COMM        NUMBER(7, 2),
    DEPTNO      NUMBER(2)
);

--기존 테이블 열구조 & 데이터
CREATE TABLE DEPT_DDL
    AS SELECT * FROM DEPT;

--기존 테이블 열구조 & 일부 데이터
CREATE TABLE EMP_DDL_30
    AS SELECT *
            FROM EMP
          WHERE DEPTNO = 30;

--열구조만 복사
CREATE TABLE EMPDEPT_DDL
    AS SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE,
              E.SAL, E.COMM, D.DEPTNO, D.DNAME, D.LOC
            FROM EMP E, DEPT D
          WHERE 1<>1;


--ALTER ~ ADD/RENAME/MODIFY/DROP 테이블 변경
CREATE TABLE EMP_ALTER
    AS SELECT * FROM EMP;

--ADD 열 추가
ALTER TABLE EMP_ALTER
    ADD HP VARCHAR2(20);

--RENAME COLUMN 열 이름 변경
ALTER TABLE EMP_ALTER
    RENAME COLUMN HP TO TEL;

--MODIFY 열 자료형 변경
ALTER TABLE EMP_ALTER
    MODIFY EMPNO NUMBER(5);

--DROP COLUMN 열 삭제
ALTER TABLE EMP_ALTER
    DROP COLUMN TEL;

SELECT * FROM EMP_ALTER;


--테이블 이름 변경 RENAME
RENAME EMP_ALTER TO EMP_RENAME;

SELECT * FROM EMP_RENAME;


--테이블 데이터 삭제 TRUNCATE (테이블 삭제아님)
--WHERE절 명시안한 DELETE문으로도 가능하지만, TRUNCATE는 ROLLBACK이 불가능 하다는 차이점
TRUNCATE TABLE EMP_RENAME;

SELECT * FROM EMP_RENAME;

--테이블 삭제 DROP
DROP TABLE EMP_RENAME;

--PRACTICE 12-1
CREATE TABLE EMP_HW(
    EMPNO       NUMBER(4),
    ENAME       VARCHAR2(10),
    JOB         VARCHAR2(9),
    MGR         NUMBER(4),
    HIREDATE    DATE,
    SAL         NUMBER(7, 2),
    COMM        NUMBER(7, 2),
    DEPTNO      NUMBER(2)
);

--PRACTICE 12-2
ALTER TABLE EMP_HW
    ADD BIGO VARCHAR2(20);

--PRACTICE 12-3
ALTER TABLE EMP_HW
    MODIFY BIGO VARCHAR2(30);

--PRACTICE 12-4
ALTER TABLE EMP_HW
    RENAME COLUMN BIGO TO REMARK;

--PRACTICE 12-5
INSERT INTO EMP_HW
    SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, NULL
        FROM EMP;

--PRACTICE 12-6
DROP TABLE EMP_HW;

SELECT * FROM EMP_HW;


--CHAPTER 13 객체 (OBJECT)
--ORACLE DATABASE TABLE
--1. USER TABLE
--2. USER DICTIONARY
--   데이터베이스를 구성하고, 운영하는데 필요한 정보 저장. 
--   데이터베이스가 생성되는 시점에 자동으로 생성됨.
--   ACCESS NOT ALLOWED BY USERS. IT INSTREAD PROVIDES 'DATA DICTIONARY VIEW'

--DATA DICTIONARY VIEW
--  USER_XXXX   DB접속 사용자 소유 객체정보
--  ALL_XXXX    DB접속 사용자 소유 객체 또는 다른사용자 소유 객체중 사용허가 받은 객체
--              즉, 사용가능한 모든 객체 정보.
--  DBA_XXXX    DB관리 위한 정보(DB관리 권한 가진 SYSTEM, SYS 사용자만 열람가능)
--  V$_XXXX     DB성능 관련정보(X$_XXXX 테이블의 뷰)

SELECT * FROM DICT;

SELECT * FROM DICTIONARY;

--USER_XXXX 접두어 가진 데이터 사전: 접속된 사용자가 소유한 객체정보 보관.
SELECT TABLE_NAME FROM USER_TABLES;

--ALL_XXXX 접두어 가진 데이터 사전
--  OWNER           VARCHAR2(30)    NOT NULL    테이블소유 사용자
--  TABLE_NAME      VARCHAR(30)     NOT NULL    테이블이름
--  TABLESPACE_NAME VARCHAR(30)     NOT NULL    테이블 스페이스 이름
--  NUM_ROWS        NUMBER                      테이블에 저장된 행 수
SELECT OWNER, TABLE_NAME FROM ALL_TABLES;

SELECT * FROM ALL_TABLES;

--DBA_XXXX 접두어 가진 데이터 사전
--SCOTT계정으로 조회 불가. SYSTEM사용자로 접속 후 조회
--cmd에서 'sqlplus system/1' 
--또는 toad에서 new connection으로 system/1 관리자로 로그인
SELECT * FROM DBA_TABLES;

SELECT * 
    FROM DBA_USERS
  WHERE USERNAME = 'SCOTT';


--더 빠른 검색을 위한 인덱스 INDEX
--특정 열데이터의 주소, 위치정보를 목록으로 만들어 놓은 것.
--인덱스 사용여부에 따라 데이터 검색방식 TABLE FULL SCAN, INDEX SCAN
--INDEX도 오라클 객체이므로 소유 사용자와 사용권한이 존재
--SCOTT계정 소유 인덱스 정보 열람할때, USER_INDEXES, USER_IND_COLUMNS과 
--같은 데이터 사전 사용.

--인덱스 정보
SELECT * FROM USER_INDEXES;

--인덱스 컬럼 정보
SELECT * FROM USER_IND_COLUMNS;


--인덱스 생성
--인덱스 생성할 테이블 및 열 지정 및 지정한 각 열 별로 인덱스 정렬순서 지정
--CREATE INDEX 인덱스이름
--  ON 테이블이름(열1 ASC or DESC,
--              열2 ASC or DESC,
--              ...             );
CREATE INDEX IDX_EMP_SAL ON EMP(SAL);

SELECT * FROM USER_IND_COLUMNS;

--인덱스 걸린 SAL열을 WHERE 검색조건으로 하여 EMP 조회시, 출력속도 빨라짐.


--  SINGLE INDEX            CREATE INDEX IDX_NAME ON EMP(SAL);

--  CONCATENATED INDEX      CREATE INDEX IDX_NAME ON EMP(SAL, ENAME, ...);
--  COMPOSITE INDEX 
--      두개이상의 열로 만들어진 인덱스, WHERE절 두열이 AND연산으로 묶이는 경우

--  UNIQUE INDEX            CREATE UNIQUE INDEX IDX_NAME ON EMP(EMPNO);
--      열에 중복데이터 없을때. UNIQUE 지정안하면 NON-UNIQUE INDEX가 디폴트

--  FUNCTION BASED INDEX    CREATE INDEX IDX_NAME ON EMP(SAL*12+COMM);
--      열에 산술식 같은 데이터 가공이 진행된 결과로 인덱스 생성

--  BITMAP INDEX            CREATE BITMAP INDEX IDX_NAME ON EMP(JOB);
--      데이터 종류가 적고 같은 데이터가 많이 존재할 때 주로 사용.


--인덱스 삭제
DROP INDEX IDX_EMP_SAL;

SELECT * FROM USER_IND_COLUMNS;

--효율적인 INDEX 사용을 위해, 인덱스 TUNING 참고


--테이블 처럼 사용하는 VIEW (VIRTUAL TABLE)
--VIEW목적: 편리성, 보안성
SELECT * FROM (SELECT EMPNO, ENAME, JOB, DEPTNO
                    FROM EMP
                  WHERE DEPTNO = 20);

--VIEW 생성
--  sqlplus system/1
--SCOTT에 VIEW 생성 권한 부여
GRANT CREATE VIEW TO SCOTT;

--CREATE[OR REPLACE] [FORCE|NOFORCE] VIEW 뷰이름 (열1, 열2, ...)
--  AS (저장할 SELECT문)
--[WITH CHECK OPTION [CONSTRAINT 제약조건]]
--[WITH READ ONLY [CONSTRAINT 제약조건]];
CREATE VIEW VM_EMP20
    AS (SELECT EMPNO, ENAME, JOB, DEPTNO
            FROM EMP
          WHERE DEPTNO = 20);

--DOUBLE-CLICK 'TEXT' COLUMN DATA TO SEE (WIDEMEMO)
SELECT VIEW_NAME,
       TEXT_LENGTH,
       TEXT 
    FROM USER_VIEWS;

SELECT * FROM VM_EMP20;

--VIEW 삭제
DROP VIEW VM_EMP20;


--INLINE VIEW를 사용한 TOP-N SQL문
--  CREATE을 통해 객체로 만들어지는 VIEW 외에 SQL문에서 일회성으로 만들어서 사용
--  1. SELECT문에서 사용되는 서브쿼리 
--  2. WITH절에 미리 이름을 정의해두고 사용하는 SELECT문
--ROWNUM 테이블 행이 조회된 순서대로 매겨진 일련번호
SELECT ROWNUM, E.*
    FROM EMP E
  ORDER BY SAL DESC;

--INLINE VIEW(서브쿼리 사용)
SELECT ROWNUM, E.*
    FROM (SELECT *
            FROM EMP E
          ORDER BY SAL DESC) E;

--INLINE VIEW(WITH절 사용)
WITH E AS (SELECT * FROM EMP ORDER BY SAL DESC)
  SELECT ROWNUM, E.*
      FROM E;

--INLINE VIEW로 TOP-N 추출하기(서브쿼리 사용)
SELECT ROWNUM, E.*
    FROM (SELECT *
            FROM EMP E
          ORDER BY SAL DESC) E
  WHERE ROWNUM <= 3;

--INLINE VIEW로 TOP-N 추출하기(WITH절 사용)
WITH E AS (SELECT * FROM EMP ORDER BY SAL DESC)
  SELECT ROWNUM, E.*
      FROM E
    WHERE ROWNUM <= 3;

--규칙에 따라 순번을 생성하는 시퀀스
--CREATE SEQUENCE 시퀀스이름
--  [INCREMENT BY N]
--  [START WITH N]
--  [MAXVALUE N | NOMAXVALUE]
--  [MINVALUE N | NOMINVALUE]
--  [CYCLE | NOCYCLE]
--  [CACHE N | NOCACHE]
CREATE TABLE DEPT_SEQUENCE
    AS SELECT *
            FROM DEPT
          WHERE 1 <> 1;

SELECT * FROM DEPT_SEQUENCE;

CREATE SEQUENCE SEQ_DEPT_SEQUENCE
    INCREMENT BY 10
    START WITH 0
    MAXVALUE 90
    MINVALUE 0
    NOCYCLE
    CACHE 2;

SELECT * FROM USER_SEQUENCES;

--시퀀스 SEQUENCE 사용
--시퀀스에서 생성한 순번을 사용해 INSERT문 실행
INSERT INTO DEPT_SEQUENCE (DEPTNO, DNAME, LOC)
    VALUES (SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');

SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;

SELECT SEQ_DEPT_SEQUENCE.CURRVAL FROM DUAL;

--시퀀스 수정
--ALTER SEQUENCE 시퀀스이름
--  [INCREMENT BY N]
--  [MAXVALUE N | NOMAXVALUE]
--  [MINVALUE N | NOMINVALUE]
--  [CYCLE | NOCYCLE]
--  [CACHE N | NOCACHE]
ALTER SEQUENCE SEQ_DEPT_SEQUENCE
    INCREMENT BY 3
    MAXVALUE 99
    CYCLE;

SELECT * FROM USER_SEQUENCES;

INSERT INTO DEPT_SEQUENCE (DEPTNO, DNAME, LOC)
    VALUES (SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');

SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;

--시퀀스 삭제
DROP SEQUENCE SEQ_DEPT_SEQUENCE;

SELECT * FROM USER_SEQUENCES;


--공식 별칭을 지정하는 동의어(SYNONYM)
--TABLE/VIEW/SEQUENCE 등 객체이름 대신 사용할 이름
--  CREATE [PUBLIC] SYNONYM 동의어이름
--  FOR [사용자][객체이름];

--sqlplus system/1
GRANT CREATE SYNONYM TO SCOTT;

GRANT CREATE PUBLIC SYNONYM TO SCOTT;

--동의어 생성
CREATE SYNONYM E FOR EMP;

SELECT * FROM E;

DROP SYNONYM E;

--PRACTICE 13-1 인덱스생성 및 확인
--1. EMPIDX 테이블 생성. 2. 인덱스 생성
--3.인덱스가 잘 생성되었는지 적절한 데이터 사전 뷰를 통해 확인
CREATE TABLE EMPIDX
    AS SELECT * FROM EMP;

CREATE INDEX IDX_EMPIDX_EMPNO
    ON EMPIDX(EMPNO);

SELECT * 
    FROM USER_INDEXES
  WHERE INDEX_NAME = 'IDX_EMPIDX_EMPNO';

SELECT * FROM USER_IND_COLUMNS;

--PRACTICE 13-2 뷰생성
CREATE OR REPLACE VIEW EMPIDX_OVER15K
    AS (SELECT EMPNO, ENAME, JOB, DEPTNO,
               SAL, NVL2(COMM, 'O', 'X') AS COMM
            FROM EMPIDX
          WHERE SAL > 1500);

SELECT * FROM EMPIDX_OVER15K;

--PRACTICE 13-3
CREATE TABLE DEPTSEQ
    AS SELECT * FROM DEPT;

CREATE SEQUENCE SEQ_DEPTSEQ
    INCREMENT BY 1
    START WITH 1
    MAXVALUE 99
    MINVALUE 1
    NOCYCLE NOCACHE;

SELECT * FROM USER_SEQUENCES;

INSERT INTO DEPTSEQ (DEPTNO, DNAME, LOC)
VALUES(SEQ_DEPTSEQ.NEXTVAL, 'DATABASE', 'SEOUL');

INSERT INTO DEPTSEQ (DEPTNO, DNAME, LOC)
VALUES(SEQ_DEPTSEQ.NEXTVAL, 'WEB', 'BUSAN');

INSERT INTO DEPTSEQ (DEPTNO, DNAME, LOC)
VALUES(SEQ_DEPTSEQ.NEXTVAL, 'MOBILE', 'ILSAN');

SELECT * FROM DEPTSEQ;


--CHAPTER 14 제약조건 CONSTRAINT (DDL로 지정)
--  NOT NULL        NULL 허용 X. NULL제외 데이터 중복은 허용
--  UNIQUE          지정된 열이 유일한 값 가져야 함. NULL은 중복에서 제외
--  PRIMARY KEY     UNIQUE & NOT NULL. 테이블에 '하나만(1개 열)' 지정가능
--  FOREIGN KEY     다른 테이블의 열을 참조하여, 존재하는 값만 입력 가능.
--  CHECK           설정한 조건식 만족하는 데이터만 입력가능

--DATA INTEGRITY(데이터 무결성)
--  DOMAIN(영역) INTEGRITY
--  ENTITY(개체) INTEGRITY
--  REFERENTIAL(참조) INTEGRITY

--테이블 생성시 제약조건 지정
CREATE TABLE TABLE_NOTNULL(
    LOGIN_ID  VARCHAR2(20) NOT NULL,
    LOGIN_PWD VARCHAR2(20) NOT NULL,
    TEL       VARCHAR2(20)
);

DESC TABLE_NOTNULL;

--ERROR! NULL DATA!
INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD, TEL)
VALUES ('TEST_ID_01', NULL, '010-1234-5678');

--ERROR! NULL DATA!
UPDATE TABLE_NOTNULL
    SET LOGIN_PWD = NULL
  WHERE LOGIN_ID = 'TEST_ID_01';

--OK
INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD)
VALUES ('TEST_ID_01', '1234');

SELECT * FROM TABLE_NOTNULL;

--USER_CONSTRAINTS 데이터 사전에서 제약조건 확인
--  OWNER
--  CONSTRAINT_NAME
--  CONSTRAINT_TYPE
--  TABLE_NAME
SELECT OWNER,
       CONSTRAINT_NAME,
       CONSTRAINT_TYPE,
       TABLE_NAME
  FROM USER_CONSTRAINTS;


--제약조건 이름 직접 지정
CREATE TABLE TABLE_NOTNULL2(
    LOGIN_ID  VARCHAR2(20) CONSTRAINT TBLNN2_LGNID_NN NOT NULL,
    LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLNN2_LGNPW_NN NOT NULL,
    TEL       VARCHAR2(20)
);

SELECT OWNER,
       CONSTRAINT_NAME,
       CONSTRAINT_TYPE,
       TABLE_NAME
  FROM USER_CONSTRAINTS;

--이미생성한 테이블 제약조건 지정
--ERROR! ORA-02296 NULL값이 발견되었습니다!
--추가된 행의 TEL열에 NULL값 존재.
ALTER TABLE TABLE_NOTNULL
MODIFY(TEL NOT NULL);

--NULL값 있는 데이터 수정
UPDATE TABLE_NOTNULL
    SET TEL = '010-1234-5678'
  WHERE LOGIN_ID = 'TEST_ID_01';

SELECT * FROM TABLE_NOTNULL;

--이제 테이블 제약조건 수정가능
ALTER TABLE TABLE_NOTNULL
MODIFY(TEL NOT NULL);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS;

--생성한 테이블에 제약조건 이름 지정해서 추가
ALTER TABLE TABLE_NOTNULL2
MODIFY(TEL CONSTRAINT TBLNN_TEL_NN NOT NULL);

--생성된 제약조건 이름 변경
ALTER TABLE TABLE_NOTNULL2
RENAME CONSTRAINT TBLNN_TEL_NN TO TBLNN2_TEL_NN;

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS;

--제약조건 삭제
ALTER TABLE TABLE_NOTNULL2
DROP CONSTRAINT TBLNN2_TEL_NN;

SELECT * FROM TABLE_NOTNULL;


--UNIQUE CONSTRAINT
CREATE TABLE TABLE_UNIQUE(
    LOGIN_ID  VARCHAR2(20) UNIQUE,
    LOGIN_PWD VARCHAR2(20) NOT NULL,
    TEL       VARCHAR2(20)
);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
    FROM USER_CONSTRAINTS
  WHERE TABLE_NAME = 'TABLE_UNIQUE';

INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');

--ERROR! UNIQUE CONSTRAINTS!
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', 'PWD01', '010-8888-7777');

--OK
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_02', 'PWD01', '010-8888-7777');

INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES(NULL, 'PWD01', '010-8888-7777');

SELECT * FROM TABLE_UNIQUE;

--ERROR! UNIQUE CONSTRAINTS
UPDATE TABLE_UNIQUE
    SET LOGIN_ID = 'TEST_ID_01'
  WHERE LOGIN_ID IS NULL;

CREATE TABLE TABLE_UNIQUE2(
    LOGIN_ID  VARCHAR2(20) CONSTRAINTS TBLUNQ2_LGNID_UNQ UNIQUE,
    LOGIN_PWD VARCHAR2(20) CONSTRAINTS TBLUNQ2_LGNPW_NN NOT NULL,
    TEL       VARCHAR2(20)
);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
    FROM USER_CONSTRAINTS
  WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

--ERROR! TEL CONTAINS NOT UNIQUE DATA
ALTER TABLE TABLE_UNIQUE
MODIFY(TEL UNIQUE);

UPDATE TABLE_UNIQUE
    SET TEL = NULL;

--OK!
ALTER TABLE TABLE_UNIQUE
MODIFY(TEL UNIQUE);

--생성된 테이블에 제약조건 이름 정해서 만들기 또는 이미 존재하는 제약조건 이름변경
ALTER TABLE TABLE_UNIQUE2
MODIFY(TEL CONSTRAINT TBLUNQ_TEL_UNQ UNIQUE);

ALTER TABLE TABLE_UNIQUE2
RENAME CONSTRAINT TBLUNQ_TEL_UNQ TO TBLUNQ2_TEL_UNQ;

--제약조건 삭제
ALTER TABLE TABLE_UNIQUE2
DROP CONSTRAINT TBLUNQ2_TEL_UNQ;

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
    FROM USER_CONSTRAINTS
  WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';


--PRIMARY KEY (UNIQUE & NOT NULL)
--특정 열을 PRIMARY KEY로 지정하면, 해당 열에 자동으로 '인덱스' 생성됨
CREATE TABLE TABLE_PK(
    LOGIN_ID  VARCHAR2(20) PRIMARY KEY,
    LOGIN_PWD VARCHAR2(20) NOT NULL,
    TEL       VARCHAR2(20)
);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
    FROM USER_CONSTRAINTS
  WHERE TABLE_NAME LIKE 'TABLE_PK%';

SELECT INDEX_NAME, TABLE_OWNER, TABLE_NAME FROM USER_INDEXES
    WHERE TABLE_NAME LIKE 'TABLE_PK%';

CREATE TABLE TABLE_PK2(
    LOGIN_ID  VARCHAR2(20) CONSTRAINT TBLPK2_LGNID_PK PRIMARY KEY,
    LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLPK2_LGNID_NN NOT NULL,
    TEL       VARCHAR2(20)
);

INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');

SELECT * FROM TABLE_PK;

--ERROR!
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');

--ERROR!
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES(NULL, 'PWD02', '010-1234-5678');

--ERROR!
INSERT INTO TABLE_PK(LOGIN_PWD, TEL)
VALUES('PWD02', '010-1234-5678');

SELECT * FROM TABLE_PK;

--DEFINE CONSTRAINTS INLINE(COLUMN-LEVEL)
CREATE TABLE TABLE_NAME(
    COL1    VARCHAR2(20) CONSTRAINT CONSTRAINT_NAME PRIMARY KEY,
    COL2    VARCHAR2(20) NOT NULL,
    COL3    VARCHAR2(20)
);

--DEFINE CONSTRAINTS OUT-OF-LINE(TABLE_LEVEL)
CREATE TABLE TABLE_NAME(
    COL1    VARCHAR2(20),
    COL2    VARCHAR2(20),
    COL3    VARCHAR2(20),
    PRIMARY KEY (COL1),
    CONSTRAINT CONSTRAINT_NAME UNIQUE (COL2)
);


--FOREIGN KEY
--  특정 테이블에서 PRIMARY KEY 제약조건 지정한 열을 다른 테이블의 특정 열에서 참조
--  (EX) EMP테이블 DEPTNO(FOREGIN KEY) -> DEPT테이블 DEPTNO(PRIMARY KEY)
--       EMP테이블 DEPTNO는 NULL또는 DEPT테이블의 DEPTNO열에 존재하는 값만 저장 가능.
--                (NULL, 10,20,30,40)

--ERROR! 50번 DEPTNO 데이터 INSERT 불가능
INSERT INTO EMP(EMPNO, ENAME, JOB, MGR, HIREDATE,SAL, COMM, DEPTNO)
VALUES(9999, '홍길동', 'CLERK', '7788', TO_DATE('2019/01/01', 'YYYY/MM/DD'),
       1200, NULL, 50);

--FOREIGN KEY 지정하기
--  1.
--  CREATE TABLE 테이블이름(
--      ...
--      [열이름] [자료형] CONSTRAINT [제약조건이름] REFERENCES 참조테이블(참조할 열)
--  );

--  2.
--  CREATE TABLE 테이블이름(
--      ...
--      [열이름] [자료형] REFERENCES 참조테이블(참조할 열)
--  );

--  3.
--  CREATE TABLE 테이블이름(
--      ...
--      CONSTRAINT [제약조건이름] FOREIGN KEY(열)
--      REFERENCES 참조테이블(참조할 열)
--  );
CREATE TABLE DEPT_FK(
    DEPTNO  NUMBER(2) CONSTRAINT DEPTFK_DEPTNO_PK PRIMARY KEY,
    DNAME   VARCHAR2(14),
    LOC     VARCHAR2(13)
);

CREATE TABLE EMP_FK(
    EMPNO       NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
    ENAME       VARCHAR2(10),
    JOB         VARCHAR2(9),
    MGR         NUMBER(4),
    HIREDATE    DATE,
    SAL         NUMBER(7, 2),
    COMM        NUMBER(7, 2),
    DEPTNO      NUMBER(2) CONSTRAINT EMPFK_DEPTNO_FK REFERENCES DEPT_FK(DEPTNO)
);

--ERROR! DEPT_FK에 데이터가 없어서 DEPT_FK 테이블의 DEPTNO를 참조할 수 없음
INSERT INTO EMP_FK
VALUES(9999, 'TEST_NAME', 'TEST_JOB', NULL, TO_DATE('2001/01/01', 'YYYY/MM/DD'),
       3000, NULL, 10);

INSERT INTO DEPT_FK
VALUES(10, 'TEST_DNAME', 'TEST_LOC');

SELECT * FROM DEPT_FK;

--OK
INSERT INTO EMP_FK
VALUES(9999, 'TEST_NAME', 'TEST_JOB', NULL, TO_DATE('2001/01/01', 'YYYY/MM/DD'),
       3000, NULL, 10);

SELECT * FROM EMP_FK;

--FOREIGN KEY로 참조행 데이터 삭제하기
--1.삭제하려는 열값을 참조하는 데이터를 먼저삭제(EMP_FK 테이블의 DEPTNO=10인 행 삭제)
--2.삭제하려는 열값을 참조하는 데이터를 수정(DEPTNO를 다른 값 혹은 NULL로 변경)
--3.삭제하려는 열을 참조하는 자식 테이블의 FOREIGN KEY 제약조건 해제(DROP)
--ERROR!
DELETE FROM DEPT_FK
WHERE DEPTNO = 10;

--열 데이터 삭제시 이 데이터를 참조하고 있는 데이터도 함께 삭제
--  DEPT_FK의 10번부서 + EMP_FK의 DEPTNO=10인 행들도 함께 삭제하도록,
--  테이블 생성시, 제약조건 처음 지정시, 다음과 같이 추가옵션을 지정하면,
--  열데이터를 삭제시 자동으로 함께 삭제됨
--CONSTRAINT [제약조건이름] REFERENCES 참조테이블(참조할 열) ON DELETE CASCADE

--열 데이터 삭제시 이 데이터를 참조하고 있는 데이터를 NULL로 수정
--CONSTRAINT [제약조건이름] REFERENCES 참조테이블(참조할 열) ON DELETE SET NULL
--  DEPT_FK의 DEPTNO=10인 데이터를 삭제하면, 이를 참조하는 EMP_FK테이블의 DEPTNO=10인
--  데이터를 전부 NULL로 수정함.



--데이터 형태와 범위를 정하는 CHECK 제약조건
CREATE TABLE TABLE_CHECK(
    LOGIN_ID  VARCHAR2(20) CONSTRAINT TBLCK_LOGINID_PK PRIMARY KEY,
    LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLCK_LOGINPW_CK CHECK (LENGTH(LOGIN_PWD)>3),
    TEL       VARCHAR2(20)
);

--ERROR! LENGTH(LOGIN_PWD) <=3
INSERT INTO TABLE_CHECK
VALUES ('TEST_ID', '123', '010-1234-5678');

--OK
INSERT INTO TABLE_CHECK
VALUES ('TEST_ID', '1234', '010-1234-5678');

SELECT * FROM TABLE_CHECK;

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
    FROM USER_CONSTRAINTS
  WHERE TABLE_NAME LIKE 'TABLE_CHECK';


--기본값을 정하는 DEFAULT
--  제약조건과 별개로 특정 열에 저장할 값이 지정되지 않았을경우, 기본값 지정가능
CREATE TABLE TABLE_DEFAULT(
    LOGIN_ID    VARCHAR2(20) CONSTRAINT TBLCK2_LOGINID_PK PRIMARY KEY,
    LOGIN_PWD   VARCHAR2(20) DEFAULT '1234',
    TEL         VARCHAR2(20)
);

INSERT INTO TABLE_DEFAULT VALUES('TEST_ID', NULL, '010-1234-5678');

INSERT INTO TABLE_DEFAULT (LOGIN_ID, TEL) VALUES('TEST_ID2', '010-1234-5678');

SELECT * FROM TABLE_DEFAULT;

--제약조건 비활성/활성화 가능
--  ALTER TABLE 테이블이름
--  DISABLE [NOVALIDATE/VALIDATE(선택)] CONSTRAINT 제약조건이름;

--  ALTER TABLE 테이블이름
--  ENABLE [NOVALIDATE/VALIDATE(선택)] CONSTRAINT 제약조건이름;

--PRACTICE 14-1
CREATE TABLE DEPT_CONST(
    DEPTNO  NUMBER(2) CONSTRAINT DEPTCONST_DEPTNO_PK PRIMARY KEY,
    DNAME   VARCHAR2(14) CONSTRAINT DEPTCONST_DNAME_UNQ UNIQUE,
    LOC     VARCHAR2(13) CONSTRAINT DEPTCONST_LOC_NN NOT NULL
);

CREATE TABLE EMP_CONST(
    EMPNO       NUMBER(4) CONSTRAINT EMPCONST_EMPNO_PK PRIMARY KEY,
    ENAME       VARCHAR2(10) CONSTRAINT EMPCONST_ENAME_NN NOT NULL,
    JOB         VARCHAR2(9),
    TEL         VARCHAR2(20) CONSTRAINT EMPCONST_TEL_UNQ UNIQUE,
    HIREDATE    DATE,
    SAL         NUMBER(7, 2) CONSTRAINT EMPCONST_SAL_CHK CHECK(SAL BETWEEN 1000 AND 9999),
    COMM        NUMBER(7, 2),
    DEPTNO      NUMBER(2) CONSTRAINT EMPCONST_DEPTNO_FK REFERENCES DEPT_CONST(DEPTNO)
);

SELECT TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_TYPE
    FROM USER_CONSTRAINTS
  WHERE TABLE_NAME IN ('EMP_CONST', 'DEPT_CONST')
ORDER BY CONSTRAINT_NAME;


--CHAPTER 15 사용자, 권한, 롤 관리

--데이터베이스 스키마 SCHEMA
--  데이터간 관계, 데이터 구조, 제약조건 등 데이터를 저장 및 관리하기 위해
--  정의한 데이터베이스 구조의 범위를 SCHEMA를 통해 그룹단위로 분류.
--  USER: SCOTT
--  SCHEMA: SCOTT이 생성한 테이블, 뷰, 제약조건, 인덱스,시퀀스,동의어 등 객체

--사용자 생성(SYSTEM 유저로만 생성가능)
--  SQLPLUS SYSTEM/1
CREATE USER ORCLSTUDY
IDENTIFIED BY ORACLE;
--DEFAULT TABLESPACE TS이름
--TEMPORARY TABLESPACE TS그룹이름
--QUOTA TS크기 ON TS이름
--PROFILE 프로파일이름
--PASSWORD EXPIRE
--ACCOUNT [LOCK/UNLOCK];

--ERROR! LACKS CREATE SESSION PRIVILEGE
CONN ORCLSTUDY/ORACLE

GRANT CREATE SESSION TO ORCLSTUDY;

--OK!
CONN ORCLSTUDY/ORACLE

--사용자 정보 조회
SELECT * FROM ALL_USERS
  WHERE USERNAME = 'ORCLSTUDY';

SELECT * FROM DBA_USERS
  WHERE USERNAME = 'ORCLSTUDY';

SELECT * FROM DBA_OBJECTS
  WHERE OWNER = 'ORCLSTUDY';

--사용자 변경과 삭제

--  유저 ORCLSTUDY의 비밀번호를 'ORCL'로 변경
ALTER USER ORCLSTUDY
IDENTIFIED BY ORCL;

DROP USER ORCLSTUDY;

--  사용자 스키마에 객체가 있을경우 CASCADE옵션으로 사용자와 객체 모두 삭제
DROP USER ORCLSTUDY CASCADE;


--권한관리
--  1.SYSTEM PRIVILEGE  2.OBJECT PRIVILEGE

--SYSTEM PRIVILEGE
--  USER (CREATE/ALTER/DROP USER)
--  SESSION (CREATE/ALTER SESSION)
--  TABLE (CREATE TABLE/
--         CREATE/ALTER/DROP/INSERT/UPDATE/DELETE/SELECT ANY TABLE
--  INDEX (CREATE/ALTER/DROP ANY INDEX)
--  VIEW
--  SEQUENCE
--  SYNONYM
--  PROFILE
--  ROLE

--시스템 권한부여
--  GRANT [시스템권한] TO [사용자/롤이름/PUBLIC] [WITH ADMIN OPTION];
GRANT CREATE SESSION TO ORCLSTUDY; -- 유저 생성(CREATE) 후, DB접속을 허가하기 위함

CREATE USER ORCLSTUDY
IDENTIFIED BY ORACLE;

GRANT RESOURCE, CREATE SESSION, CREATE TABLE TO ORCLSTUDY;

CONN ORCLSTUDY/STUDY;

CREATE TABLE TEMP1(
    COL1 VARCHAR2(20),
    COL2 VARCHAR2(20)
);

INSERT INTO TEMP1 VALUES ('USERS', 'GRANT_TEST');

SELECT * FROM TEMP1;

--  RESOURCE는 오라클 DB에서 제공하는 ROLE중 하나입니다. ROLE은 여러 권한을 하나의 
--  이름으로 묶어 권한부여 관련작업을 간편하게
--  RESOURCE 권한 없다면, CREATE이나 INSERT시 오류: 테이블 스페이스 USERS 권한이 없습니다
--  테이블을 저장하는 공간; 미지정시, 'USERS' 테이블스페이스 할당.

--  RESOURCE는 UNLIMITED TABLESPACE권한을 포함하므로, QUOTA절로 사용역역 제한
ALTER USER ORCLSTUDY 
QUOTA 2M ON USERS;

--시스템 권한 취소
--  REVOKE [시스템권한] FROM [사용자/ROLE/PUBLIC];

CONN SYSTEM/ORACLE;

REVOKE RESOURCE, CREATE TABLE FROM ORCLSTUDY;

--ERROR! PRIVILIEGE
CREATE TABLE TEMP2(
    COL1 VARCHAR2(20),
    COL2 VARCHAR2(20)
);


--객체권한 (OBJECT PRIVILEGE)
--  특정 사용자가 생성한 테이블,인덱스,뷰,시퀀스 등과 관련된 권한
--  (EX) SCOTT소유 테이블에 ORCLSTUDY사용자가 SELECT,INSERT 등의 작업 가능하도록 허용.

--  객체권한분류      객체권한
--  TABLE           ALTER/DELETE/INDEX/INSERT/REFERENCES/SELECT/UPDATE
--  VIEW            DELETE/INSERT/REFERENCES/SELECT/UPDATE
--  SEQUENCE        ALTER/SELECT
--  PROCEDURE
--  FUNCTION
--  PACKAGE


--객체권한 부여
--  GRANT [객체권한/ALL PRIVILEGES]
--      ON [스키마.객체이름]
--      TO [사용자/ROLE/PUBLIC]
--      [WITH GRANT OPTION];
CONN SCOTT/TIGER;

CREATE TABLE TEMP(
    COL1 VARCHAR2(20),
    COL2 VARCHAR2(20)
);

GRANT SELECT ON TEMP TO ORCLSTUDY;

GRANT INSERT ON TEMP TO ORCLSTUDY;

GRANT SELECT, INSERT ON TEMP TO ORCLSTUDY;

--  권한이 부여됐는지 확인!
CONN ORCLSTUDY/ORACLE;

SELECT * FROM SCOTT.TEMP;

INSERT INTO SCOTT.TEMP VALUES('TEXT', 'FROM ORCLSTUDY');

SELECT * FROM SCOTT.TEMP;

--객체권한 취소
CONN SCOTT/TIGER;

REVOKE SELECT, INSERT ON TEMP FROM ORCLSTUDY;

CONN ORCLSTUDY/ORACLE;

--ERROR! PRIVILEGE
SELECT * FROM SCOTT.TEMP;


--롤 관리
--  여러종류의 권한을 묶어놓은 그룹
--  PREDEFINED ROLES / USER ROLES

--1. 사전 정의된 롤 PREDEFINED ROLES
--  CONNECT ROLE:
--      ALTER SESSION, CREATE CLUSTER, CREATE DATABASE LINK, CREATE SEQUENCE,
--      CREATE SESSION(10G부터는 이 권한만), CREATE SYNONYM, CREATE TABLE, CREATE VIEW
--  RESOURCE ROLE:
--      CREATE TRIGGER, CREATE SEQUENCE, CREATE TYPE, CREATE PROCEDURE,
--      CREATE CLUSTER, CREATE OPERATOR, CREATE INDEXTYPE, CREATE TABLE
--  DBA ROLE: DB관리하는 시스템 권한을 대부분 가지고 있음. (202개 권한)

--2. 사용자 정의 롤 USER ROLES
--  필요에 의해 직접 권한을 포함시킨 롤; 다음절차에 따라 롤을 생성해서 사요
--  1. CREATE ROLE으로 ROLE 생성
--  2. GRANT 명령어로 생성한 롤에 권한을 포함
--  3. GRANT로 권한이 포함된 롤을 특정 사용자에게 부여
--  4. REVOKE로 롤을 취소

--  롤생성과 권한 포함
--CONN SYSTEM/1;
CREATE ROLE ROLESTUDY;

GRANT CONNECT, RESOURCE, CREATE VIEW, CREATE SYNONYM
    TO ROLESTUDY;

GRANT ROLESTUDY TO ORCLSTUDY;

--  부여된 롤과 권한 확인
CONN ORCLSTUDY/ORACLE;

SELECT * FROM USER_SYS_PRIVS;

SELECT * FROM USER_ROLE_PRIVS;

--  부여된 롤 취소
CONN SYSTEM/ORACLE

REVOKE ROLESTUDY FROM ORCLSTUDY;

--  롤 삭제
DROP ROLE ROLESTUDY;


--CHAPTER 16 PL/SQL
--  DECLARE : 실행에 필요한 변수/상수/커서 선언
--  BEGIN (필수) : 작업을 위해 실제실행하는 명령어; 조건문/반복문/SELECT/DML/함수 정의
--  EXCEPTION : PL/SQL 실행 중 발생 오류 처리
SET SERVEROUTPUT ON; --실행결과를 화면에 출력

BEGIN
    DBMS_OUTPUT.PUT_LINE('HELLO, PL/SQL!');
END;
/

--PL/SQL주석 --한줄 /*여러줄*/
DECLARE
V_EMPNO NUMBER(4) := 7788;
V_ENAME VARCHAR2(10);
BEGIN
V_ENAME := 'SCOTT';
--  DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_EMPNO);
DBMS_OUTPUT.PUT_LINE('V_ENAME : ' || V_ENAME);
END;
/

DECLARE
V_EMPNO NUMBER(4) := 7788;
V_ENAME VARCHAR2(10);
BEGIN
V_ENAME := 'SCOTT';
/*
DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_EMPNO);
DBMS_OUTPUT.PUT_LINE('V_ENAME : ' || V_ENAME);
*/
END;
/

--변수와 상수
--  [변수이름][자료형] := 값또는 값이 도출되는 표현식;
DECLARE
    V_EMPNO NUMBER(4) := 7788;
    V_ENAME VARCHAR2(10);
BEGIN
    V_ENAME := 'SCOTT';
    DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_EMPNO);
    DBMS_OUTPUT.PUT_LINE('V_ENAME : ' || V_ENAME);
END;
/

--  상수
--  [변수이름] CONSTANT [자료형] := 값또는 값이 도출되는 표현식;
DECLARE
    V_TAX CONSTANT NUMBER(1) := 3;
BEGIN
    DBMS_OUTPUT.PUT_LINE('V_TEXT : ' || V_TAX);
END;
/

--  변수의 기본값 지정하기
--  [변수이름][자료형] DEFAULT 값또는 값이 도출되는 표현식;
DECLARE
    V_DEPTNO NUMBER(2) DEFAULT 10;
BEGIN
    DBMS_OUTPUT.PUT_LINE('V_DEPTNO : ' || V_DEPTNO);
END;
/

--  변수에 NULL값 저장 막기
--  [변수이름][자료형] NOT NULL [:= 또는 DEFAULT] 값또는 값이 도출되는 표현식;
DECLARE
    V_DEPTNO NUMBER(2) NOT NULL := 10;
BEGIN
    DBMS_OUTPUT.PUT_LINE('V_DEPTNO : ' || V_DEPTNO);
END;
/

DECLARE
    V_DEPTNO NUMBER(2) NOT NULL DEFAULT 10;
BEGIN
    DBMS_OUTPUT.PUT_LINE('V_DEPTNO : ' || V_DEPTNO);
END;
/

--  변수이름 정하기
--  1.블록내 식별자는 고유해야; 중복안됨
--  2.대소문자 구분하지 않음
--  3.테이블이름 붙이는 규칙과 같은 규칙.
--      1)이름은 문자로 시작;한글도 가능
--      2)이름은 30BYTE(영어 30자) 이하; 한글은 15자까지
--      3)이름은 영문자,한글,숫자,특수문자($ # _) 가능
--      4)SQL키워드는 이름으로 사용불가 (SELECT, FROM 같은 키워드)

--변수의 자료형
--  SCALAR, COMPOSITE, REFERENCE, LOB(LARGE OBJECT)

--스칼라형 (SCALAR TYPE)
--  NUMBER      숫자
--  CHAR        문자열 (고정길이)
--  VARCHAR2    문자열 (가변길이)
--  DATE        날짜
--  BOOLEAN     논리 데이터

--참조형 (REFERENCE TYPE)
--  [변수이름][테이블].[열이름]%TYPE;
DECLARE
    V_DEPTNO DEPT.DEPTNO%TYPE := 50;
BEGIN
    DBMS_OUTPUT.PUT_LINE('V_DEPTNO : ' || V_DEPTNO);
END;
/

--  [변수이름][테이블]%ROWTYPE;
--      하나의 열이 아닌 행 구조 전체를 참조할 때
DECLARE
    V_DEPT_ROW DEPT%ROWTYPE;
BEGIN
    --변수 V_DEPT_ROW에 값을 대입
    SELECT DEPTNO, DNAME, LOC INTO V_DEPT_ROW
        FROM DEPT
      WHERE DEPTNO = 40;
    DBMS_OUTPUT.PUT_LINE('DEPTNO : ' || V_DEPT_ROW.DEPTNO);
    DBMS_OUTPUT.PUT_LINE('DNAME : ' || V_DEPT_ROW.DNAME);
    DBMS_OUTPUT.PUT_LINE('LOC : ' || V_DEPT_ROW.LOC);
END;
/

--복합형(COLLECTION, RECORD), LOB형(BLOB, CLOB)


--조건제어문
--IF-THEN ELSE IF ELSE 
DECLARE
    V_NUMBER NUMBER := 14;
BEGIN
    IF MOD(V_NUMBER, 2) = 1 THEN
        DBMS_OUTPUT.PUT_LINE('V_NUMBER는 홀수입니다!');
    ELSE
        DBMS_OUTPUT.PUT_LINE('V_NUMBER는 짝수입니다!');
    END IF;
END;

DECLARE
    V_SCORE NUMBER := 87;
BEGIN
    IF V_SCORE >= 90 THEN
        DBMS_OUTPUT.PUT_LINE('A학점');
    ELSIF V_SCORE >= 80 THEN
        DBMS_OUTPUT.PUT_LINE('B학점');
    ELSIF V_SCORE >= 70 THEN
        DBMS_OUTPUT.PUT_LINE('C학점');
    ELSIF V_SCORE >= 60 THEN
        DBMS_OUTPUT.PUT_LINE('D학점');
    ELSE
        DBMS_OUTPUT.PUT_LINE('F학점');
    END IF;
END;
/

--CASE조건문
DECLARE
    V_SCORE NUMBER := 87;
BEGIN
    CASE TRUNC(V_SCORE/10)
        WHEN 10 THEN DBMS_OUTPUT.PUT_LINE('A학점');
        WHEN 9 THEN DBMS_OUTPUT.PUT_LINE('B학점');
        WHEN 8 THEN DBMS_OUTPUT.PUT_LINE('C학점');
        WHEN 7 THEN DBMS_OUTPUT.PUT_LINE('D학점');
        ELSE DBMS_OUTPUT.PUT_LINE('F학점');
    END CASE;
END;
/

--반복제어문
--WHILE
